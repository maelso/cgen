//
// auto-generated by ops.py
//
void ops_init_backend();
#include <iostream>
#include <stdlib.h>
#include <math.h>

double dx, dy, dt;

double nx, ny;

#define PREVIOUS 0
#define CURRENT 1
#define NEXT 2
#define M_PI 3.14159265358979323846
#define BORDER_SIZE 20
#define CPML 20
#define SOURCE_LOCATION_X 0
#define SOURCE_LOCATION_Y 0
#define RICKER_PEAK_FREQUENCY 5
#define MAX_VELOCITY 5000

#define OPS_2D
#include  "ops_lib_cpp.h"

//
// ops_par_loop declarations
//

void ops_par_loop_initializeAxBx(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg,
  ops_arg );

void ops_par_loop_initializeAyBy(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg,
  ops_arg );

void ops_par_loop_wavePropagation(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg );

void ops_par_loop_sourceInjection(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg );

void ops_par_loop_update_omega(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg );

void ops_par_loop_update_zeta(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg,
  ops_arg );

void ops_par_loop_makeCopy(char const *, ops_block, int , int*,
  ops_arg,
  ops_arg );


#include <ops_lib_cpp.h>
#include <sources.cpp>
#include <velocity-model.cpp>
#include <wave-propagation-ops.h>

using namespace std;

void wavePropagation(double *u_new, double const *u_current, double const *u_previous, double const *velocity, double const *wx, double const *wy, double const *zetax, double const *zetay, int const *idx)
{

    u_new[OPS_ACC0(0, 0)] = (velocity[OPS_ACC3(0, 0)] * velocity[OPS_ACC3(0, 0)]) *
                                ((-205.0 / 72) * u_current[OPS_ACC1(0, 0)] +
                                 (8.0 / 5) * (u_current[OPS_ACC1(1, 0)] + u_current[OPS_ACC1(-1, 0)] + u_current[OPS_ACC1(0, 1)] + u_current[OPS_ACC1(0, -1)]) +
                                 (-0.2) * (u_current[OPS_ACC1(2, 0)] + u_current[OPS_ACC1(-2, 0)] + u_current[OPS_ACC1(0, 2)] + u_current[OPS_ACC1(0, -2)]) +
                                 (8.0 / 315) * (u_current[OPS_ACC1(3, 0)] + u_current[OPS_ACC1(-3, 0)] + u_current[OPS_ACC1(0, 3)] + u_current[OPS_ACC1(0, -3)]) +
                                 (-1.0 / 560.0) * (u_current[OPS_ACC1(4, 0)] + u_current[OPS_ACC1(-4, 0)] + u_current[OPS_ACC1(0, 4)] + u_current[OPS_ACC1(0, -4)])) +
                            2 * u_current[OPS_ACC1(0, 0)] - u_previous[OPS_ACC2(0, 0)];

    u_new[OPS_ACC0(0, 0)] += velocity[OPS_ACC3(0, 0)] * velocity[OPS_ACC3(0, 0)] * dx * (wx[OPS_ACC4(1, 0)] - wx[OPS_ACC4(-1, 0)] + wy[OPS_ACC5(0, 1)] - wy[OPS_ACC5(0, -1)]) * 0.5 +
                             velocity[OPS_ACC3(0, 0)] * velocity[OPS_ACC3(0, 0)] * dx * dy * (zetax[OPS_ACC6(0, 0)] + zetay[OPS_ACC7(0, 0)]);

}

void sourceInjection(double *u_new, double const *value)
{
    u_new[OPS_ACC0(0, 0)] += *value;
}

void update_omega(double *wx, double *wy, double const *ax, double const *ay, double const *bx, double const *by, double const *u_next, int const *idx)
{
    wx[OPS_ACC0(0, 0)] = bx[OPS_ACC4(0, 0)] * wx[OPS_ACC0(0, 0)] +
                         ax[OPS_ACC2(0, 0)] * (u_next[OPS_ACC6(1, 0)] - u_next[OPS_ACC6(-1, 0)]) / (2 * dx);
    wy[OPS_ACC1(0, 0)] = by[OPS_ACC5(0, 0)] * wy[OPS_ACC1(0, 0)] +
                         ay[OPS_ACC3(0, 0)] * (u_next[OPS_ACC6(0, 1)] - u_next[OPS_ACC6(0, -1)]) / (2 * dy);

}

void update_zeta(double *zetax, double *zetay, double const *wx, double const *wy, double const *ax, double const *ay, double const *bx, double const *by, double const *u_next, int const *idx)
{
    zetax[OPS_ACC0(0, 0)] = bx[OPS_ACC6(0, 0)] * zetax[OPS_ACC0(0, 0)] +
                            ax[OPS_ACC4(0, 0)] * (u_next[OPS_ACC8(1, 0)] - (2 * u_next[OPS_ACC8(0, 0)]) + u_next[OPS_ACC8(-1, 0)]) / (dx * dx) +
                            ax[OPS_ACC4(0, 0)] * (wx[OPS_ACC2(1, 0)] - wx[OPS_ACC2(-1, 0)]) / (2 * dx);


    zetay[OPS_ACC1(0, 0)] = by[OPS_ACC7(0, 0)] * zetay[OPS_ACC1(0, 0)] +
                            ay[OPS_ACC5(0, 0)] * (u_next[OPS_ACC8(0, 1)] - (2 * u_next[OPS_ACC8(0, 0)]) + u_next[OPS_ACC8(0, -1)]) / (dy * dy) +
                            ay[OPS_ACC5(0, 0)] * (wy[OPS_ACC3(0, 1)] - wy[OPS_ACC3(0, -1)]) / (2 * dy);

}

void initializeAxBx(double *ax, double *bx, int const *idx)
{

    double d_x, b_x, f_x, alfa_x;
    double Lx;

    Lx = CPML * dx;


    if (idx[0] < 0)
      f_x = Lx - (idx[0] + CPML) * dx;
    else
      if (idx[0] > nx - 2 * CPML)
        f_x = dx * (idx[0] - nx + 2 * CPML);
      else
        f_x = 0;

    alfa_x = M_PI * RICKER_PEAK_FREQUENCY * (Lx - f_x) / Lx;
    d_x = -3.0 * log(0.00001) / (2.0 * Lx) * MAX_VELOCITY * (f_x / Lx) * (f_x / Lx);
    b_x = exp(-dt * (d_x + alfa_x));

    ax[OPS_ACC0(0, 0)] = d_x * (b_x - 1) / (d_x + alfa_x);
    bx[OPS_ACC1(0, 0)] = exp(-dt * (d_x + alfa_x));
}

void initializeAyBy(double *ay, double *by, int const *idx)
{

    double d_y, b_y, f_y, alfa_y;
    double Ly;

    Ly = CPML * dy;


    if (idx[0] < 0)
    {
        f_y = Ly - (idx[0] + CPML) * dy;
    }
    else
      if (idx[0] > ny - 2 * CPML)
      {
          f_y = dy * (idx[0] - ny + 2 * CPML);
      }
      else
      {
          f_y = 0.0;
      }

    alfa_y = M_PI * RICKER_PEAK_FREQUENCY * (Ly - f_y) / Ly;
    d_y = -3.0 * log(0.00001) / (2.0 * Ly) * MAX_VELOCITY * (f_y / Ly) * (f_y / Ly);
    b_y = exp(-dt * (d_y + alfa_y));

    ay[OPS_ACC0(0, 0)] = d_y * (b_y - 1) / (d_y + alfa_y);
    by[OPS_ACC1(0, 0)] = exp(-dt * (d_y + alfa_y));
}

void makeCopy(double *to, double const *from)
{
    to[OPS_ACC0(0, 0)] = from[OPS_ACC1(0, 0)];
}

void save_array(char filename[], double *array, int size)
{
    FILE *fp;
    int i;

    fp = fopen(filename, "w");

    for (i = 0; i < size; i++)
    {
        fprintf(fp, "%lf ", array[i]);
    }
    fflush(fp);
    fclose(fp);
}

int propagationCPML(int xSize, int ySize, int xIntervals, int yIntervals, int tTotal, int tIntervals)
{

    double **u, *source;

    int i, j, t;


    int size[2];

    int base[] = {0, 0};

    int d_m[] = {-BORDER_SIZE, -BORDER_SIZE};

    int d_p[] = {BORDER_SIZE, BORDER_SIZE};

    ops_block wave_grid;

    ops_dat d_u_Previous, d_u_Current, d_u_Next, d_velocity;


    double *wx, *wy, *zetax, *zetay;
    double *ax, *bx, *ay, *by;

    int s1d_0[] = {0};
    int s2d_00[] = {0, 0};
    int s2d_8th[] = {0, 0, 1, 0, -1, 0, 2, 0, -2, 0, 3, 0, -3, 0, 4, 0, -4, 0, 0, 1, 0, -1, 0, 2, 0, -2, 0, 3, 0, -3, 0, 4, 0, -4};
    int s2d_2px[] = {1, 0, -1, 0};
    int s2d_2py[] = {0, 1, 0, -1};
    int s2d_4pt[] = {1, 0, -1, 0, 0, 1, 0, -1};
    int s2d_5pt[] = {1, 0, 0, 0, -1, 0, 0, 1, 0, -1};
    int stride2d_x[] = {1, 0};

    int stride2d_y[] = {0, 1};

    ops_dat d_wx, d_wy, d_zetax, d_zetay;
    ops_dat d_ax, d_ay, d_bx, d_by;
    ops_block wave_grid_1d;

    ops_init(1, NULL, 1);
  ops_init_backend();

    nx = xIntervals + 2 * BORDER_SIZE;
    ny = yIntervals + 2 * BORDER_SIZE;

    size[0] = xIntervals;
    size[1] = yIntervals;

    dx = (double)xSize / (double)xIntervals;
    dy = (double)ySize / (double)yIntervals;
    dt = (double)tTotal / (double)tIntervals;

    printf("dx=%lf | dy=%lf | dt=%lf\n", dx, dy, dt);
    printf("nx=%d | ny=%d | nT=%d | borders=%d\n", xIntervals, yIntervals, tIntervals, BORDER_SIZE);

    if (dt / dx > 1 && dt / dy > 1)
    {
        cout << "Does not comply with CFL conditions." << endl;
        return -1;
    }

    ops_decl_const2("dx", 1, "double", &dx);
    ops_decl_const2("dy", 1, "double", &dy);
    ops_decl_const2("dt", 1, "double", &dt);
    ops_decl_const2("nx", 1, "double", &nx);
    ops_decl_const2("ny", 1, "double", &ny);

    int range_CPML[] = {1 - BORDER_SIZE, xIntervals + BORDER_SIZE - 1, 1 - BORDER_SIZE, yIntervals + BORDER_SIZE - 1};
    int range_CPML_aux_1D_X_init[] = {-BORDER_SIZE, xIntervals + BORDER_SIZE - 1, 0, 1};
    int range_CPML_aux_1D_Y_init[] = {0, 1, -BORDER_SIZE, yIntervals + BORDER_SIZE - 1};
    int range[] = {-BORDER_SIZE + 4, xIntervals + BORDER_SIZE - 4 - 1, -BORDER_SIZE + 4, yIntervals + BORDER_SIZE - 4 - 1};

    int whole_range[] = {-BORDER_SIZE, xIntervals + BORDER_SIZE, -BORDER_SIZE, yIntervals + BORDER_SIZE};

    u = (double **)malloc(3 * sizeof(double *));
    for (t = 0; t < 3; t++)
    {
        u[t] = (double *)calloc((xIntervals + 2 * BORDER_SIZE) * (yIntervals + 2 * BORDER_SIZE), sizeof(double));
    }

    source = rickerSource(dt, tIntervals, RICKER_PEAK_FREQUENCY);


    wx = (double *)calloc((xIntervals + 2 * BORDER_SIZE) * (yIntervals + 2 * BORDER_SIZE), sizeof(double));
    wy = (double *)calloc((xIntervals + 2 * BORDER_SIZE) * (yIntervals + 2 * BORDER_SIZE), sizeof(double));
    zetax = (double *)calloc((xIntervals + 2 * BORDER_SIZE) * (yIntervals + 2 * BORDER_SIZE), sizeof(double));
    zetay = (double *)calloc((xIntervals + 2 * BORDER_SIZE) * (yIntervals + 2 * BORDER_SIZE), sizeof(double));
    ax = (double *)calloc((xIntervals + 2 * BORDER_SIZE), sizeof(double));
    bx = (double *)calloc((xIntervals + 2 * BORDER_SIZE), sizeof(double));
    ay = (double *)calloc((yIntervals + 2 * BORDER_SIZE), sizeof(double));
    by = (double *)calloc((yIntervals + 2 * BORDER_SIZE), sizeof(double));

    wave_grid = ops_decl_block(2, "wave_grid");
    wave_grid_1d = ops_decl_block(1, "wave_grid_1d");

    ops_stencil S1D_0 = ops_decl_stencil(1, 1, s1d_0, "0");
    ops_stencil S2D_00 = ops_decl_stencil(2, 1, s2d_00, "0,0");
    ops_stencil S2D_8TH = ops_decl_stencil(2, 17, s2d_8th, "8th");
    ops_stencil S2D_2PX = ops_decl_stencil(2, 2, s2d_2px, "2px");
    ops_stencil S2D_2PY = ops_decl_stencil(2, 2, s2d_2py, "2py");
    ops_stencil S2D_4PT = ops_decl_stencil(2, 4, s2d_4pt, "4pt");
    ops_stencil S2D_5PT = ops_decl_stencil(2, 5, s2d_5pt, "5pt");
    ops_stencil S2D_00_STRIDE_X = ops_decl_strided_stencil(2, 1, s2d_00, stride2d_x, "s2D_00_stride2D_x");
    ops_stencil S2D_00_STRIDE_Y = ops_decl_strided_stencil(2, 1, s2d_00, stride2d_y, "s2D_00_stride2D_y");

    d_m[0] = -BORDER_SIZE;
    d_m[1] = -BORDER_SIZE;
    d_p[0] = BORDER_SIZE;
    d_p[1] = BORDER_SIZE;
    d_u_Previous = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, u[PREVIOUS], "double", "u_previous");
    d_u_Current = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, u[CURRENT], "double", "u_current");
    d_u_Next = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, u[NEXT], "double", "u_next");

    size[0] = xIntervals;
    size[1] = yIntervals;
    d_wx = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, wx, "double", "wx");
    d_wy = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, wy, "double", "wy");
    d_zetax = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, zetax, "double", "zetax");
    d_zetay = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, zetay, "double", "zetay");

    d_m[0] = -BORDER_SIZE;
    d_m[1] = 0;
    d_p[0] = BORDER_SIZE;
    d_p[1] = 0;
    size[0] = xIntervals;
    size[1] = 1;
    d_ax = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, ax, "double", "d_ax");
    d_bx = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, bx, "double", "d_bx");
    d_m[0] = 0;
    d_m[1] = -BORDER_SIZE;
    d_p[0] = 0;
    d_p[1] = BORDER_SIZE;
    size[0] = 1;
    size[1] = yIntervals;
    d_ay = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, ay, "double", "d_ay");
    d_by = ops_decl_dat(wave_grid, 1, size, base, d_m, d_p, by, "double", "d_by");

    int source_location_range[] = {SOURCE_LOCATION_X, SOURCE_LOCATION_X + 1, SOURCE_LOCATION_Y, SOURCE_LOCATION_Y + 1};
    double source_field_factor = getVelocityAtSourcePoint(FourHorizontalLayers, SOURCE_LOCATION_X, SOURCE_LOCATION_Y, xIntervals, yIntervals) * dt;
    source_field_factor = source_field_factor * source_field_factor / (dx * dy);
    double source_magnitude = 0;

    d_velocity = initializeFourHorizontalLayersModel(xIntervals, yIntervals, BORDER_SIZE, dt, dx);


    ops_par_loop_initializeAxBx("initializeAxBx", wave_grid, 2, range_CPML_aux_1D_X_init,
                 ops_arg_dat(d_ax, 1, S2D_00, "double", OPS_WRITE),
                 ops_arg_dat(d_bx, 1, S2D_00, "double", OPS_WRITE),
                 ops_arg_idx());

    ops_par_loop_initializeAyBy("initializeAyBy", wave_grid, 2, range_CPML_aux_1D_X_init,
                 ops_arg_dat(d_ay, 1, S2D_00, "double", OPS_WRITE),
                 ops_arg_dat(d_by, 1, S2D_00, "double", OPS_WRITE),
                 ops_arg_idx());





    t = 0;
    do
    {

        ops_par_loop_wavePropagation("wave_propagation", wave_grid, 2, range,
                     ops_arg_dat(d_u_Next, 1, S2D_00, "double", OPS_RW),
                     ops_arg_dat(d_u_Current, 1, S2D_8TH, "double", OPS_READ),
                     ops_arg_dat(d_u_Previous, 1, S2D_00, "double", OPS_READ),
                     ops_arg_dat(d_velocity, 1, S2D_00, "double", OPS_READ),
                     ops_arg_dat(d_wx, 1, S2D_2PX, "double", OPS_READ),
                     ops_arg_dat(d_wy, 1, S2D_2PY, "double", OPS_READ),
                     ops_arg_dat(d_zetax, 1, S2D_00, "double", OPS_READ),
                     ops_arg_dat(d_zetay, 1, S2D_00, "double", OPS_READ),
                     ops_arg_idx());

        source_magnitude = source_field_factor * source[t];

        ops_par_loop_sourceInjection("source_injection", wave_grid, 2, source_location_range,
                     ops_arg_dat(d_u_Next, 1, S2D_00, "double", OPS_WRITE),
                     ops_arg_gbl(&source_magnitude, 1, "double", OPS_READ));

        ops_par_loop_update_omega("update_omega", wave_grid, 2, range_CPML,
                     ops_arg_dat(d_wx, 1, S2D_00, "double", OPS_RW),
                     ops_arg_dat(d_wy, 1, S2D_00, "double", OPS_RW),
                     ops_arg_dat(d_ax, 1, S2D_00_STRIDE_X, "double", OPS_READ),
                     ops_arg_dat(d_ay, 1, S2D_00_STRIDE_Y, "double", OPS_READ),
                     ops_arg_dat(d_bx, 1, S2D_00_STRIDE_X, "double", OPS_READ),
                     ops_arg_dat(d_by, 1, S2D_00_STRIDE_Y, "double", OPS_READ),
                     ops_arg_dat(d_u_Next, 1, S2D_4PT, "double", OPS_READ),
                     ops_arg_idx());


        ops_par_loop_update_zeta("update_zeta", wave_grid, 2, range_CPML,
                     ops_arg_dat(d_zetax, 1, S2D_00, "double", OPS_WRITE),
                     ops_arg_dat(d_zetay, 1, S2D_00, "double", OPS_WRITE),
                     ops_arg_dat(d_wx, 1, S2D_2PX, "double", OPS_READ),
                     ops_arg_dat(d_wy, 1, S2D_2PY, "double", OPS_READ),
                     ops_arg_dat(d_ax, 1, S2D_00_STRIDE_X, "double", OPS_READ),
                     ops_arg_dat(d_ay, 1, S2D_00_STRIDE_Y, "double", OPS_READ),
                     ops_arg_dat(d_bx, 1, S2D_00_STRIDE_X, "double", OPS_READ),
                     ops_arg_dat(d_by, 1, S2D_00_STRIDE_Y, "double", OPS_READ),
                     ops_arg_dat(d_u_Next, 1, S2D_5PT, "double", OPS_READ),
                     ops_arg_idx());







        ops_par_loop_makeCopy("copy_current_to_previous", wave_grid, 2, whole_range,
                     ops_arg_dat(d_u_Previous, 1, S2D_00, "double", OPS_WRITE),
                     ops_arg_dat(d_u_Current, 1, S2D_00, "double", OPS_READ));

        ops_par_loop_makeCopy("copy_next_to_current", wave_grid, 2, whole_range,
                     ops_arg_dat(d_u_Current, 1, S2D_00, "double", OPS_WRITE),
                     ops_arg_dat(d_u_Next, 1, S2D_00, "double", OPS_READ));




        t++;
    }
    while (t < tIntervals);

    ops_print_dat_to_txtfile(d_u_Current, "output/u-ops.txt");

    ops_exit();




}
